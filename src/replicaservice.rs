// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// 
/// bool        Boolean, one byte
/// i8 (byte)   Signed 8-bit integer
/// i16         Signed 16-bit integer
/// i32         Signed 32-bit integer
/// i64         Signed 64-bit integer
/// double      64-bit floating point value
/// string      String
/// binary      Blob (byte array)
/// map<t1,t2>  Map from one type to another
/// list<t1>    Ordered list of one type
/// set<t1>     Set of unique elements of one type
/// 
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EntryType {
  EmptyEntry = 1,
  SetMappingEntry = 2,
  ConfigChangeEntry = 3,
  NoopEntry = 4,
}

impl EntryType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EntryType> {
    let enum_value = i_prot.read_i32()?;
    EntryType::try_from(enum_value)  }
}

impl TryFrom<i32> for EntryType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(EntryType::EmptyEntry),
      2 => Ok(EntryType::SetMappingEntry),
      3 => Ok(EntryType::ConfigChangeEntry),
      4 => Ok(EntryType::NoopEntry),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EntryType", i)
            )
          )
        )
      },
    }
  }
}

//
// Entry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Entry {
  pub type_: Option<EntryType>,
  pub key: Option<String>,
  pub value: Option<String>,
  pub term: Option<i32>,
  pub client_identifier: Option<String>,
  pub request_identifier: Option<i32>,
  pub new_configuration: Option<Vec<Box<ID>>>,
}

impl Entry {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(type_: F1, key: F2, value: F3, term: F4, client_identifier: F5, request_identifier: F6, new_configuration: F7) -> Entry where F1: Into<Option<EntryType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<Vec<Box<ID>>>> {
    Entry {
      type_: type_.into(),
      key: key.into(),
      value: value.into(),
      term: term.into(),
      client_identifier: client_identifier.into(),
      request_identifier: request_identifier.into(),
      new_configuration: new_configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Entry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<EntryType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<Vec<Box<ID>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = EntryType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<ID>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(ID::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Entry {
      type_: f_1,
      key: f_2,
      value: f_3,
      term: f_4,
      client_identifier: f_5,
      request_identifier: f_6,
      new_configuration: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entry");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.term {
      o_prot.write_field_begin(&TFieldIdentifier::new("term", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.client_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientIdentifier", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.request_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestIdentifier", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.new_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("newConfiguration", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Entry {
  fn default() -> Self {
    Entry{
      type_: None,
      key: Some("".to_owned()),
      value: Some("".to_owned()),
      term: Some(0),
      client_identifier: Some("".to_owned()),
      request_identifier: Some(0),
      new_configuration: Some(Vec::new()),
    }
  }
}

//
// AppendEntryResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppendEntryResponse {
  pub success: Option<bool>,
  pub term: Option<i32>,
  pub prev_log_index: Option<i32>,
  pub number_of_entries_added: Option<i32>,
}

impl AppendEntryResponse {
  pub fn new<F1, F2, F3, F4>(success: F1, term: F2, prev_log_index: F3, number_of_entries_added: F4) -> AppendEntryResponse where F1: Into<Option<bool>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<i32>> {
    AppendEntryResponse {
      success: success.into(),
      term: term.into(),
      prev_log_index: prev_log_index.into(),
      number_of_entries_added: number_of_entries_added.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AppendEntryResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppendEntryResponse {
      success: f_1,
      term: f_2,
      prev_log_index: f_3,
      number_of_entries_added: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppendEntryResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.term {
      o_prot.write_field_begin(&TFieldIdentifier::new("term", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.prev_log_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("prevLogIndex", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.number_of_entries_added {
      o_prot.write_field_begin(&TFieldIdentifier::new("numberOfEntriesAdded", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppendEntryResponse {
  fn default() -> Self {
    AppendEntryResponse{
      success: Some(false),
      term: Some(0),
      prev_log_index: Some(0),
      number_of_entries_added: Some(0),
    }
  }
}

//
// Ballot
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Ballot {
  pub vote_granted: Option<bool>,
  pub term: Option<i32>,
}

impl Ballot {
  pub fn new<F1, F2>(vote_granted: F1, term: F2) -> Ballot where F1: Into<Option<bool>>, F2: Into<Option<i32>> {
    Ballot {
      vote_granted: vote_granted.into(),
      term: term.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Ballot> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Ballot {
      vote_granted: f_1,
      term: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Ballot");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.vote_granted {
      o_prot.write_field_begin(&TFieldIdentifier::new("voteGranted", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.term {
      o_prot.write_field_begin(&TFieldIdentifier::new("term", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Ballot {
  fn default() -> Self {
    Ballot{
      vote_granted: Some(false),
      term: Some(0),
    }
  }
}

//
// ID
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ID {
  pub hostname: Option<String>,
  pub port: Option<i32>,
}

impl ID {
  pub fn new<F1, F2>(hostname: F1, port: F2) -> ID where F1: Into<Option<String>>, F2: Into<Option<i32>> {
    ID {
      hostname: hostname.into(),
      port: port.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ID> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ID {
      hostname: f_1,
      port: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ID");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hostname {
      o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.port {
      o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ID {
  fn default() -> Self {
    ID{
      hostname: Some("".to_owned()),
      port: Some(0),
    }
  }
}

//
// PutResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PutResponse {
  pub success: Option<i32>,
  pub leader_i_d: Option<ID>,
}

impl PutResponse {
  pub fn new<F1, F2>(success: F1, leader_i_d: F2) -> PutResponse where F1: Into<Option<i32>>, F2: Into<Option<ID>> {
    PutResponse {
      success: success.into(),
      leader_i_d: leader_i_d.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PutResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<ID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PutResponse {
      success: f_1,
      leader_i_d: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PutResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.leader_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("leaderID", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PutResponse {
  fn default() -> Self {
    PutResponse{
      success: Some(0),
      leader_i_d: None,
    }
  }
}

//
// GetResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetResponse {
  pub success: Option<bool>,
  pub value: Option<String>,
  pub leader_i_d: Option<ID>,
}

impl GetResponse {
  pub fn new<F1, F2, F3>(success: F1, value: F2, leader_i_d: F3) -> GetResponse where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<ID>> {
    GetResponse {
      success: success.into(),
      value: value.into(),
      leader_i_d: leader_i_d.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<ID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ID::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetResponse {
      success: f_1,
      value: f_2,
      leader_i_d: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.leader_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("leaderID", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetResponse {
  fn default() -> Self {
    GetResponse{
      success: Some(false),
      value: Some("".to_owned()),
      leader_i_d: None,
    }
  }
}

//
// ReplicaService service client
//

pub trait TReplicaServiceSyncClient {
  fn request_vote(&mut self, term: i32, candidate_i_d: ID, last_log_index: i32, last_log_term: i32) -> thrift::Result<Ballot>;
  fn append_entry(&mut self, term: i32, leader_i_d: ID, prev_log_index: i32, prev_log_term: i32, entry: Entry, leader_commit: i32) -> thrift::Result<AppendEntryResponse>;
  fn get(&mut self, key: String, client_identifier: String, request_identifier: i32) -> thrift::Result<GetResponse>;
  fn put(&mut self, key: String, value: String, client_identifier: String, request_identifier: i32) -> thrift::Result<PutResponse>;
  fn kill(&mut self) -> thrift::Result<()>;
  fn get_information(&mut self) -> thrift::Result<BTreeMap<String, String>>;
  fn start(&mut self) -> thrift::Result<()>;
  fn install_snapshot(&mut self, leader_term: i32, leader_i_d: ID, last_included_index: i32, last_included_term: i32, offset: i32, data: Vec<u8>, done: bool) -> thrift::Result<i32>;
  fn add_new_configuration(&mut self, endpoints: Vec<ID>) -> thrift::Result<bool>;
}

pub trait TReplicaServiceSyncClientMarker {}

pub struct ReplicaServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ReplicaServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ReplicaServiceSyncClient<IP, OP> {
    ReplicaServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ReplicaServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TReplicaServiceSyncClientMarker for ReplicaServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TReplicaServiceSyncClientMarker> TReplicaServiceSyncClient for C {
  fn request_vote(&mut self, term: i32, candidate_i_d: ID, last_log_index: i32, last_log_term: i32) -> thrift::Result<Ballot> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestVote", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceRequestVoteArgs { term: term, candidate_i_d: candidate_i_d, last_log_index: last_log_index, last_log_term: last_log_term };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestVote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceRequestVoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_entry(&mut self, term: i32, leader_i_d: ID, prev_log_index: i32, prev_log_term: i32, entry: Entry, leader_commit: i32) -> thrift::Result<AppendEntryResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("appendEntry", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceAppendEntryArgs { term: term, leader_i_d: leader_i_d, prev_log_index: prev_log_index, prev_log_term: prev_log_term, entry: entry, leader_commit: leader_commit };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("appendEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceAppendEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get(&mut self, key: String, client_identifier: String, request_identifier: i32) -> thrift::Result<GetResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceGetArgs { key: key, client_identifier: client_identifier, request_identifier: request_identifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceGetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn put(&mut self, key: String, value: String, client_identifier: String, request_identifier: i32) -> thrift::Result<PutResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("put", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServicePutArgs { key: key, value: value, client_identifier: client_identifier, request_identifier: request_identifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("put", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServicePutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn kill(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("kill", TMessageType::OneWay, self.sequence_number());
        let call_args = ReplicaServiceKillArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    Ok(())
  }
  fn get_information(&mut self) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getInformation", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceGetInformationArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getInformation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceGetInformationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start", TMessageType::OneWay, self.sequence_number());
        let call_args = ReplicaServiceStartArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    Ok(())
  }
  fn install_snapshot(&mut self, leader_term: i32, leader_i_d: ID, last_included_index: i32, last_included_term: i32, offset: i32, data: Vec<u8>, done: bool) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("installSnapshot", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceInstallSnapshotArgs { leader_term: leader_term, leader_i_d: leader_i_d, last_included_index: last_included_index, last_included_term: last_included_term, offset: offset, data: data, done: done };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("installSnapshot", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceInstallSnapshotResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_new_configuration(&mut self, endpoints: Vec<ID>) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addNewConfiguration", TMessageType::Call, self.sequence_number());
        let call_args = ReplicaServiceAddNewConfigurationArgs { endpoints: endpoints };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addNewConfiguration", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ReplicaServiceAddNewConfigurationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ReplicaService service processor
//

pub trait ReplicaServiceSyncHandler {
  fn handle_request_vote(&self, term: i32, candidate_i_d: ID, last_log_index: i32, last_log_term: i32) -> thrift::Result<Ballot>;
  fn handle_append_entry(&self, term: i32, leader_i_d: ID, prev_log_index: i32, prev_log_term: i32, entry: Entry, leader_commit: i32) -> thrift::Result<AppendEntryResponse>;
  fn handle_get(&self, key: String, client_identifier: String, request_identifier: i32) -> thrift::Result<GetResponse>;
  fn handle_put(&self, key: String, value: String, client_identifier: String, request_identifier: i32) -> thrift::Result<PutResponse>;
  fn handle_kill(&self) -> thrift::Result<()>;
  fn handle_get_information(&self) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_start(&self) -> thrift::Result<()>;
  fn handle_install_snapshot(&self, leader_term: i32, leader_i_d: ID, last_included_index: i32, last_included_term: i32, offset: i32, data: Vec<u8>, done: bool) -> thrift::Result<i32>;
  fn handle_add_new_configuration(&self, endpoints: Vec<ID>) -> thrift::Result<bool>;
}

pub struct ReplicaServiceSyncProcessor<H: ReplicaServiceSyncHandler> {
  handler: H,
}

impl <H: ReplicaServiceSyncHandler> ReplicaServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ReplicaServiceSyncProcessor<H> {
    ReplicaServiceSyncProcessor {
      handler,
    }
  }
  fn process_request_vote(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_request_vote(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_append_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_get(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_put(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_put(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_kill(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_kill(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_information(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_get_information(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_start(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_install_snapshot(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_install_snapshot(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_new_configuration(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TReplicaServiceProcessFunctions::process_add_new_configuration(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TReplicaServiceProcessFunctions;

impl TReplicaServiceProcessFunctions {
  pub fn process_request_vote<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServiceRequestVoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_vote(args.term, args.candidate_i_d, args.last_log_index, args.last_log_term) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("requestVote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceRequestVoteResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestVote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("requestVote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_entry<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServiceAppendEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_entry(args.term, args.leader_i_d, args.prev_log_index, args.prev_log_term, args.entry, args.leader_commit) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("appendEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceAppendEntryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("appendEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("appendEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServiceGetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get(args.key, args.client_identifier, args.request_identifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceGetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_put<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServicePutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_put(args.key, args.value, args.client_identifier, args.request_identifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("put", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServicePutResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("put", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("put", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_kill<H: ReplicaServiceSyncHandler>(handler: &H, _: i32, i_prot: &mut dyn TInputProtocol, _: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ReplicaServiceKillArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_kill() {
      Ok(_) => {
        Ok(())
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            Err(thrift::Error::Application(app_err))
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            Err(thrift::Error::Application(ret_err))
          },
        }
      },
    }
  }
  pub fn process_get_information<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ReplicaServiceGetInformationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_information() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getInformation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceGetInformationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getInformation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("getInformation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start<H: ReplicaServiceSyncHandler>(handler: &H, _: i32, i_prot: &mut dyn TInputProtocol, _: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ReplicaServiceStartArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start() {
      Ok(_) => {
        Ok(())
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            Err(thrift::Error::Application(app_err))
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            Err(thrift::Error::Application(ret_err))
          },
        }
      },
    }
  }
  pub fn process_install_snapshot<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServiceInstallSnapshotArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_install_snapshot(args.leader_term, args.leader_i_d, args.last_included_index, args.last_included_term, args.offset, args.data, args.done) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("installSnapshot", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceInstallSnapshotResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("installSnapshot", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("installSnapshot", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_new_configuration<H: ReplicaServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ReplicaServiceAddNewConfigurationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_new_configuration(args.endpoints) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("addNewConfiguration", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ReplicaServiceAddNewConfigurationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addNewConfiguration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("addNewConfiguration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ReplicaServiceSyncHandler> TProcessor for ReplicaServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "requestVote" => {
        self.process_request_vote(message_ident.sequence_number, i_prot, o_prot)
      },
      "appendEntry" => {
        self.process_append_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "get" => {
        self.process_get(message_ident.sequence_number, i_prot, o_prot)
      },
      "put" => {
        self.process_put(message_ident.sequence_number, i_prot, o_prot)
      },
      "kill" => {
        self.process_kill(message_ident.sequence_number, i_prot, o_prot)
      },
      "getInformation" => {
        self.process_get_information(message_ident.sequence_number, i_prot, o_prot)
      },
      "start" => {
        self.process_start(message_ident.sequence_number, i_prot, o_prot)
      },
      "installSnapshot" => {
        self.process_install_snapshot(message_ident.sequence_number, i_prot, o_prot)
      },
      "addNewConfiguration" => {
        self.process_add_new_configuration(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ReplicaServiceRequestVoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceRequestVoteArgs {
  term: i32,
  candidate_i_d: ID,
  last_log_index: i32,
  last_log_term: i32,
}

impl ReplicaServiceRequestVoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceRequestVoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<ID> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServiceRequestVoteArgs.term", &f_1)?;
    verify_required_field_exists("ReplicaServiceRequestVoteArgs.candidate_i_d", &f_2)?;
    verify_required_field_exists("ReplicaServiceRequestVoteArgs.last_log_index", &f_3)?;
    verify_required_field_exists("ReplicaServiceRequestVoteArgs.last_log_term", &f_4)?;
    let ret = ReplicaServiceRequestVoteArgs {
      term: f_1.expect("auto-generated code should have checked for presence of required fields"),
      candidate_i_d: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_log_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      last_log_term: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestVote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("term", TType::I32, 1))?;
    o_prot.write_i32(self.term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("candidateID", TType::Struct, 2))?;
    self.candidate_i_d.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastLogIndex", TType::I32, 3))?;
    o_prot.write_i32(self.last_log_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastLogTerm", TType::I32, 4))?;
    o_prot.write_i32(self.last_log_term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceRequestVoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceRequestVoteResult {
  result_value: Option<Ballot>,
}

impl ReplicaServiceRequestVoteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceRequestVoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Ballot> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Ballot::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceRequestVoteResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceRequestVoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Ballot> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceRequestVote"
          )
        )
      )
    }
  }
}

//
// ReplicaServiceAppendEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceAppendEntryArgs {
  term: i32,
  leader_i_d: ID,
  prev_log_index: i32,
  prev_log_term: i32,
  entry: Entry,
  leader_commit: i32,
}

impl ReplicaServiceAppendEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceAppendEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<ID> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<Entry> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Entry::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.term", &f_1)?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.leader_i_d", &f_2)?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.prev_log_index", &f_3)?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.prev_log_term", &f_4)?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.entry", &f_5)?;
    verify_required_field_exists("ReplicaServiceAppendEntryArgs.leader_commit", &f_6)?;
    let ret = ReplicaServiceAppendEntryArgs {
      term: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leader_i_d: f_2.expect("auto-generated code should have checked for presence of required fields"),
      prev_log_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      prev_log_term: f_4.expect("auto-generated code should have checked for presence of required fields"),
      entry: f_5.expect("auto-generated code should have checked for presence of required fields"),
      leader_commit: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("appendEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("term", TType::I32, 1))?;
    o_prot.write_i32(self.term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderID", TType::Struct, 2))?;
    self.leader_i_d.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prevLogIndex", TType::I32, 3))?;
    o_prot.write_i32(self.prev_log_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prevLogTerm", TType::I32, 4))?;
    o_prot.write_i32(self.prev_log_term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entry", TType::Struct, 5))?;
    self.entry.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderCommit", TType::I32, 6))?;
    o_prot.write_i32(self.leader_commit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceAppendEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceAppendEntryResult {
  result_value: Option<AppendEntryResponse>,
}

impl ReplicaServiceAppendEntryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceAppendEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AppendEntryResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AppendEntryResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceAppendEntryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceAppendEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AppendEntryResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceAppendEntry"
          )
        )
      )
    }
  }
}

//
// ReplicaServiceGetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceGetArgs {
  key: String,
  client_identifier: String,
  request_identifier: i32,
}

impl ReplicaServiceGetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceGetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServiceGetArgs.key", &f_1)?;
    verify_required_field_exists("ReplicaServiceGetArgs.client_identifier", &f_2)?;
    verify_required_field_exists("ReplicaServiceGetArgs.request_identifier", &f_3)?;
    let ret = ReplicaServiceGetArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_identifier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      request_identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIdentifier", TType::String, 2))?;
    o_prot.write_string(&self.client_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestIdentifier", TType::I32, 3))?;
    o_prot.write_i32(self.request_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceGetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceGetResult {
  result_value: Option<GetResponse>,
}

impl ReplicaServiceGetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceGetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceGetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceGetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceGet"
          )
        )
      )
    }
  }
}

//
// ReplicaServicePutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServicePutArgs {
  key: String,
  value: String,
  client_identifier: String,
  request_identifier: i32,
}

impl ReplicaServicePutArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServicePutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServicePutArgs.key", &f_1)?;
    verify_required_field_exists("ReplicaServicePutArgs.value", &f_2)?;
    verify_required_field_exists("ReplicaServicePutArgs.client_identifier", &f_3)?;
    verify_required_field_exists("ReplicaServicePutArgs.request_identifier", &f_4)?;
    let ret = ReplicaServicePutArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      request_identifier: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("put_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIdentifier", TType::String, 3))?;
    o_prot.write_string(&self.client_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("requestIdentifier", TType::I32, 4))?;
    o_prot.write_i32(self.request_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServicePutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServicePutResult {
  result_value: Option<PutResponse>,
}

impl ReplicaServicePutResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServicePutResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PutResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PutResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServicePutResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServicePutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PutResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServicePut"
          )
        )
      )
    }
  }
}

//
// ReplicaServiceKillArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceKillArgs {
}

impl ReplicaServiceKillArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceKillArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceKillArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("kill_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceGetInformationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceGetInformationArgs {
}

impl ReplicaServiceGetInformationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceGetInformationArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceGetInformationArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getInformation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceGetInformationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceGetInformationResult {
  result_value: Option<BTreeMap<String, String>>,
}

impl ReplicaServiceGetInformationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceGetInformationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_1 = i_prot.read_string()?;
            let map_val_2 = i_prot.read_string()?;
            val.insert(map_key_1, map_val_2);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceGetInformationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceGetInformationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceGetInformation"
          )
        )
      )
    }
  }
}

//
// ReplicaServiceStartArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceStartArgs {
}

impl ReplicaServiceStartArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceStartArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceStartArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceInstallSnapshotArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceInstallSnapshotArgs {
  leader_term: i32,
  leader_i_d: ID,
  last_included_index: i32,
  last_included_term: i32,
  offset: i32,
  data: Vec<u8>,
  done: bool,
}

impl ReplicaServiceInstallSnapshotArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceInstallSnapshotArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<ID> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<Vec<u8>> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.leader_term", &f_1)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.leader_i_d", &f_2)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.last_included_index", &f_3)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.last_included_term", &f_4)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.offset", &f_5)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.data", &f_6)?;
    verify_required_field_exists("ReplicaServiceInstallSnapshotArgs.done", &f_7)?;
    let ret = ReplicaServiceInstallSnapshotArgs {
      leader_term: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leader_i_d: f_2.expect("auto-generated code should have checked for presence of required fields"),
      last_included_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      last_included_term: f_4.expect("auto-generated code should have checked for presence of required fields"),
      offset: f_5.expect("auto-generated code should have checked for presence of required fields"),
      data: f_6.expect("auto-generated code should have checked for presence of required fields"),
      done: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("installSnapshot_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderTerm", TType::I32, 1))?;
    o_prot.write_i32(self.leader_term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderID", TType::Struct, 2))?;
    self.leader_i_d.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastIncludedIndex", TType::I32, 3))?;
    o_prot.write_i32(self.last_included_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastIncludedTerm", TType::I32, 4))?;
    o_prot.write_i32(self.last_included_term)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I32, 5))?;
    o_prot.write_i32(self.offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 6))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("done", TType::Bool, 7))?;
    o_prot.write_bool(self.done)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceInstallSnapshotResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceInstallSnapshotResult {
  result_value: Option<i32>,
}

impl ReplicaServiceInstallSnapshotResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceInstallSnapshotResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceInstallSnapshotResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceInstallSnapshotResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceInstallSnapshot"
          )
        )
      )
    }
  }
}

//
// ReplicaServiceAddNewConfigurationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceAddNewConfigurationArgs {
  endpoints: Vec<ID>,
}

impl ReplicaServiceAddNewConfigurationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceAddNewConfigurationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ID>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ID> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = ID::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplicaServiceAddNewConfigurationArgs.endpoints", &f_1)?;
    let ret = ReplicaServiceAddNewConfigurationArgs {
      endpoints: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addNewConfiguration_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endpoints", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.endpoints.len() as i32))?;
    for e in &self.endpoints {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplicaServiceAddNewConfigurationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ReplicaServiceAddNewConfigurationResult {
  result_value: Option<bool>,
}

impl ReplicaServiceAddNewConfigurationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplicaServiceAddNewConfigurationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReplicaServiceAddNewConfigurationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplicaServiceAddNewConfigurationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ReplicaServiceAddNewConfiguration"
          )
        )
      )
    }
  }
}

